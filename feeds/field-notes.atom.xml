<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Phil Elson - Software | Science | Python - field-notes</title><link href="https://pelson.github.io/" rel="alternate"></link><link href="https://pelson.github.io/feeds/field-notes.atom.xml" rel="self"></link><id>https://pelson.github.io/</id><updated>2018-05-29T00:00:00+01:00</updated><entry><title>Investigating containment testing on LFRic's cubedsphere</title><link href="https://pelson.github.io/2018/LFRic_containment/" rel="alternate"></link><published>2018-05-29T00:00:00+01:00</published><updated>2018-05-29T00:00:00+01:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2018-05-29:2018/LFRic_containment/</id><summary type="html">&lt;p&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h1 id="UGRID-and-LFRic:-Polygon-mesh-intersections"&gt;UGRID and LFRic: Polygon mesh intersections&lt;a class="anchor-link" href="#UGRID-and-LFRic:-Polygon-mesh-intersections"&gt;&amp;#182;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;I'm aiming to investigate whether it is possible to use the existing python tools to compute intersections of cells definied on the Met Office's &lt;a href="https://www.metoffice.gov.uk/research/modelling-systems/lfric"&gt;LFRic&lt;/a&gt; cubesphere. A (possibly out of date but still enlightening) presentation about the LFRic datamodel can also be found &lt;a href="https://is.enes.org/documents/Talks/crossing-the-chasm/mullerworth_data-models-within-lfric"&gt;here …&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;</summary><category term="LFRic"></category><category term="cartopy"></category><category term="shapely"></category><category term="xarray"></category></entry><entry><title>Analysing walks on the South West Coast Path</title><link href="https://pelson.github.io/2018/coast-path/" rel="alternate"></link><published>2018-05-26T00:00:00+01:00</published><updated>2018-05-26T00:00:00+01:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2018-05-26:2018/coast-path/</id><summary type="html">&lt;p&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;I'm fortunate to live near to one of the best continuous coastal walking/hiking routes in the world. The UK's &lt;a href="https://www.southwestcoastpath.org.uk/"&gt;South West Coast Path&lt;/a&gt; is a scenic, cultural and culinary delight spanning 630 miles from Minehead to Poole. It is steeped with history, and apparently was originally created by the …&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;</summary><category term="fiona"></category><category term="shapely"></category><category term="folium"></category><category term="cartopy"></category></entry><entry><title>Creating a continuous integration service to check CLAs on GitHub</title><link href="https://pelson.github.io/2017/scitools_cla_service/" rel="alternate"></link><published>2017-08-13T00:00:00+01:00</published><updated>2017-08-13T00:00:00+01:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-08-13:2017/scitools_cla_service/</id><summary type="html">&lt;p&gt;Contributor license agreements are a thing. As much as I dislike the bureaucracy of them, they do provide some additional cover
to the owners of an open source project, and some companies insist on having them. I find myself in such a situation in the
&lt;a href="https://github.com/SciTools"&gt;SciTools&lt;/a&gt; organisation, for which I am one of the lead developers. We have a CLA form, a signing process, and a list of signatories -
but the really painful part is having to remember to cross check that list of signatories each time we want to merge a pull request.&lt;/p&gt;
&lt;p&gt;This is the story of how (and to some extent why) I went about automating that process.&lt;/p&gt;
</summary><category term="GitHub"></category><category term="CLA"></category><category term="heroku"></category><category term="tornado"></category></entry><entry><title>Converting rasters to SVG, and creating a rudimentary font with font-forge - Part 4 of an XKCD font saga</title><link href="https://pelson.github.io/2017/xkcd_font_raster_to_vector_and_basic_font_creation/" rel="alternate"></link><published>2017-04-21T00:00:00+01:00</published><updated>2017-04-21T00:00:00+01:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-04-21:2017/xkcd_font_raster_to_vector_and_basic_font_creation/</id><summary type="html">&lt;p&gt;In &lt;a href="https://pelson.github.io/2017/xkcd_font_classifying_strokes/"&gt;part three&lt;/a&gt; of my XKCD font saga I generated several hundred glyphs as PPM images, and
classified them with their associated character(s). In this instalment, I will convert the raster glyphs into vector form (SVG) and then
generate a rudimentary font using fontforge.&lt;/p&gt;
</summary><category term="XKCD"></category><category term="fonts"></category><category term="Python"></category></entry><entry><title>Classifying segmented strokes as characters - Part 3 of an XKCD font saga</title><link href="https://pelson.github.io/2017/xkcd_font_classifying_strokes/" rel="alternate"></link><published>2017-04-01T00:00:00+01:00</published><updated>2017-04-01T00:00:00+01:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-04-01:2017/xkcd_font_classifying_strokes/</id><summary type="html">&lt;p&gt;In &lt;a href="https://pelson.github.io/2017/xkcd_font_merge_then_extract_glyphs/"&gt;part two&lt;/a&gt; of my XKCD font saga I was able to separate strokes from the XKCD
handwriting dataset into many smaller images. I also handled the easier cases of merging some of the strokes back together - I particularly
focussed on "dotty" or "liney" type glyphs, such as i, !, % and =.&lt;/p&gt;
&lt;p&gt;Now I want to attribute a Unicode character to my segmented images, so that I can subsequently generate a font-file. 
We are well and truly in the domain of optical character recognition (OCR) here, but because I want absolute control of the results
(and 100% accuracy) I'm going to take the simple approach of mapping glyph positions to characters myself.&lt;/p&gt;
</summary><category term="XKCD"></category><category term="fonts"></category><category term="Python"></category></entry><entry><title>Segment, extract, and combine features of an image with SciPy and scikit-image - Part 2 of an XKCD font saga</title><link href="https://pelson.github.io/2017/xkcd_font_merge_then_extract_glyphs/" rel="alternate"></link><published>2017-03-20T00:00:00+00:00</published><updated>2017-03-20T00:00:00+00:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-03-20:2017/xkcd_font_merge_then_extract_glyphs/</id><summary type="html">&lt;p&gt;In &lt;a href="https://pelson.github.io/2017/xkcd_font/"&gt;part one&lt;/a&gt; of XKCD font saga I gave some background on the XKCD handwriting dataset, and took an initial look at image
segmentation in order to extract the individual strokes from the scanned image.
In this instalment, I will apply the technique from part 1, as well as attempting to merge together strokes to form (some of) the glyphs desired.&lt;/p&gt;
&lt;p&gt;I'm going to pay particular attention to "dotted" glyphs, such as "i", "j", ";" and "?". I will need to do future work to merge together
non-dotted glyphs such as the two arrows from "≫", as these are indistinguishable from two characters that happen to be close to one another.&lt;/p&gt;
</summary><category term="XKCD"></category><category term="fonts"></category><category term="Python"></category></entry><entry><title>Playing with Randall Munroe's XKCD handwriting</title><link href="https://pelson.github.io/2017/xkcd_font/" rel="alternate"></link><published>2017-03-16T00:00:00+00:00</published><updated>2017-03-16T00:00:00+00:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-03-16:2017/xkcd_font/</id><summary type="html">&lt;p&gt;The XKCD font (as used by matplotlib et al.) recently &lt;a href="https://github.com/ipython/xkcd-font/pull/13"&gt;got an update&lt;/a&gt; to include lower-case characters.
For some time now I have been aware of a handwriting sample produced by Randall Munroe (XKCD's creator) that I was interested in exploring.
The ultimate aim is to automatically produce a font-file using open source tools, and to learn a few things along the way.&lt;/p&gt;
</summary><category term="XKCD"></category><category term="fonts"></category><category term="Python"></category></entry><entry><title>Mounting a FUSE filesystem in Heroku</title><link href="https://pelson.github.io/2017/heroku_fuse_mount/" rel="alternate"></link><published>2017-02-06T00:00:00+00:00</published><updated>2017-02-06T00:00:00+00:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-02-06:2017/heroku_fuse_mount/</id><summary type="html">&lt;p&gt;This evening I'm going to take a different approach to how I would normaly blog.&lt;/p&gt;
&lt;p&gt;Rather than reporting the results of a technical investigation or highlighting a new/shiny package, I wanted to
paint a realistic picture of the technical exploration process.&lt;/p&gt;
&lt;p&gt;As it happens, this particular investigation consumed a couple of hours and appears to have drawn an unsucessful
result. Despite this, the learnings are invaluable as they will be directly and immediately applicable to other areas of my work.&lt;/p&gt;
</summary><category term="Heroku"></category><category term="FUSE"></category><category term="python"></category><category term="docker"></category></entry></feed>